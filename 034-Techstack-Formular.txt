0) Installationnpm i multer1) Datenbank erweitern (db/index.js)Füge die Inhalte-Tabelle (mit FK zum User) und neue DB-Funktionen ein.Im Code stehen Kommentare, was genau passiert.1.1 Migration ergänzen (in migrate(instance))  // -------------------------------  // Inhalte-Tabelle für das Upload-Feature  // -------------------------------  // Zweck:  // - Inhalte gehören immer einem User (owner_id -> users.id)  // - Bildpfad wird als TEXT gespeichert (relative Web-URL wie "/uploads/abc.jpg")  // - category ist eingeschränkt auf definierte Werte (CHECK)  // - ON DELETE CASCADE: löscht ein User-Account, fallen seine Inhalte mit  instance.exec(`    CREATE TABLE IF NOT EXISTS contents (      id          INTEGER PRIMARY KEY AUTOINCREMENT,      title       TEXT NOT NULL,      description TEXT NOT NULL,      category    TEXT NOT NULL CHECK(category IN ('sifi','krimi','horror','komödie')),      image_path  TEXT NOT NULL,      owner_id    INTEGER NOT NULL,      created_at  TEXT NOT NULL DEFAULT (datetime('now')),      FOREIGN KEY(owner_id) REFERENCES users(id) ON DELETE CASCADE    `);  // -- Performance-Index: neueste zuerst    CREATE INDEX IF NOT EXISTS idx_contents_created_at ON contents(created_at DESC);  // -- Filter-Index: schnelle Abfragen pro Kategorie    CREATE INDEX IF NOT EXISTS idx_contents_category ON contents(category);   // -- Join-Index: schnelle Abfragen pro Besitzer    CREATE INDEX IF NOT EXISTS idx_contents_owner ON contents(owner_id);  `);1.2 DB-Funktionen ergänzen (unter deine Exports)// Inhalte einfügen (wird aus der POST-Route aufgerufen)// Erwartet: { title, description, category, imagePath, ownerId }export function insertContent({ title, description, category, imagePath, ownerId }) {  if (!db) return null;  const stmt = db.prepare(`    INSERT INTO contents (title, description, category, image_path, owner_id, created_at)    VALUES (?, ?, ?, ?, ?, datetime('now'))  `);  const info = stmt.run(title, description, category, imagePath, ownerId);  return info.lastInsertRowid; // für Redirects/Tests nützlich}// Inhalte für die öffentliche Liste ladenexport function listContents() {  if (!db) return [];  const rows = db.prepare(`    SELECT      c.id, c.title, c.description, c.category, c.image_path,      c.created_at, u.name AS owner_name    FROM contents c    LEFT JOIN users u ON u.id = c.owner_id    ORDER BY c.created_at DESC  `).all();  return rows.map(r => ({    id: r.id,    title: r.title,    description: r.description,    category: r.category,    imagePath: r.image_path,    ownerName: r.owner_name,    createdAt: new Date(r.created_at),  }));}
2) Server anpassen (app.js)Wir richten Multer ein (Dateiupload), definieren Kategorien, und fügen geschützte Routen hinzu.Kommentare im Code erklären Zweck und Sicherheit.2.1 Imports ergänzen (oben)import multer from "multer";import crypto from "node:crypto";import fs from "node:fs";import { insertContent, listContents } from "./db/index.js";2.2 Upload-Ordner sicherstellen (direkt nach const app = express();)// Wir speichern Uploads unter /public/uploads, damit sie statisch serviert werden.// Achtung: In realen Apps oft besser über ein CDN oder einen Storage-Dienst.const uploadDir = path.join(__dirname, "public", "uploads");fs.mkdirSync(uploadDir, { recursive: true });// Upload-Verzeichnis sicherstellenfs.mkdirSync(uploadDir, { recursive: true });// Multer Storage & Filter DEFINIEREN (einmalig)const storage = multer.diskStorage({  destination: (req, file, cb) => cb(null, uploadDir),  filename: (req, file, cb) => {    const ext = path.extname(file.originalname).toLowerCase();    const name = crypto.randomBytes(16).toString("hex");    cb(null, `${name}${ext}`);  },});const fileFilter = (req, file, cb) => {  const ok = ["image/jpeg", "image/png", "image/webp", "image/gif"].includes(file.mimetype);  cb(ok ? null : new Error("Nur Bildformate (jpg, png, webp, gif) erlaubt"), ok);};2.3 Multer konfigurieren (unter 2.2)// Storage-Strategie: Dateiname = Zeitstempel + Zufall + (geprüfte) Extensionconst storage = multer.diskStorage({  destination: (req, file, cb) => cb(null, uploadDir),  filename: (req, file, cb) => {    const ext = path.extname(file.originalname || "").toLowerCase();    const allowed = [".jpg", ".jpeg", ".png", ".webp", ".gif"];    const safeExt = allowed.includes(ext) ? ext : ".bin"; // Fallback, falls unbekannt    const name = `${Date.now()}-${crypto.randomBytes(8).toString("hex")}${safeExt}`;    cb(null, name);  }});// Sicherheit: nur Bilder erlauben (MIME), max. 5 MBfunction fileFilter(req, file, cb) {  const ok = ["image/jpeg", "image/png", "image/webp", "image/gif"].includes(file.mimetype);  cb(ok ? null : new Error("Nur Bilddateien (jpg, png, webp, gif) erlaubt."), ok);}const upload = multer({  storage,  fileFilter,  limits: { fileSize: 5 * 1024 * 1024 } // 5 MB});2.4 Kategorien definieren (unter Multer)// Einheitliche Quelle für erlaubte Kategorien (DB-Check nutzt dieselben Werte)const CATEGORIES = ["sifi", "krimi", "horror", "komödie"];2.5 Routen: Formular (nur eingeloggt) & Speichern (mit Upload)// Formular anzeigen (nur eingeloggte User). requireAuth hast du bereits im Projekt.app.get("/content/new", requireAuth, (req, res) => {  // Wir liefern Kategorien & ggf. vorherige Eingaben (values) an das Template.  res.render("content_new", { title: "Neuer Inhalt", categories: CATEGORIES });});// Formular absenden: Validieren, Datei speichern, DB schreiben.// Wichtig: upload.single('image') muss zum <input name="image"> passen.app.post("/content", requireAuth, upload.single("image"), (req, res) => {  const { title, description, category } = req.body || {};  const errors = [];  // --- Eingaben prüfen (Server-seitig, niemals nur auf Client verlassen)  if (!title?.trim()) errors.push("Titel ist erforderlich.");  if (!description?.trim()) errors.push("Beschrieb ist erforderlich.");  if (!CATEGORIES.includes(category)) errors.push("Ungültige Kategorie.");  if (!req.file) errors.push("Bild ist erforderlich.");  if (errors.length) {    // Aufräumen: Wenn Upload schon stattgefunden hat, Datei löschen    if (req.file) {      try { fs.unlinkSync(path.join(uploadDir, req.file.filename)); } catch { /* ignore */ }    }    return res.status(400).render("content_new", {      title: "Neuer Inhalt",      categories: CATEGORIES,      errors,      values: { title, description, category }    });  }  // Pfad, der im Browser erreichbar ist (statische Auslieferung via /public)  const webPath = "/uploads/" + req.file.filename;  // Besitzer des Inhalts aus der Session (User muss eingeloggt sein ? requireAuth)  const ownerId = req.session.user.id;  // Schreiben in die DB (setzt created_at automatisch)  insertContent({    title: title.trim(),    description: description.trim(),    category,    imagePath: webPath,    ownerId  });  // UX: Nach Erfolg zur öffentlichen Liste  res.redirect("/content");});2.6 Öffentliche Liste (jeder darf sehen)// Öffentliche Seite: listet alle Inhalte (neueste zuerst)app.get("/content", (req, res) => {  const items = listContents();  res.render("content_list", { title: "Inhalte", items });});// Optional im Header.hbs-Partial Links ergänzen:<a href="/content">Inhalte</a>{{#if currentUser}}<a href="/content/new">Neu</a>{{/if}}
3) Views (Handlebars)Kommentare in den Templates erklären, wie Daten/Fehler angezeigt werden.3.1 views/content_new.hbs<h1>{{title}}</h1>{{!-- Fehlermeldungen vom Server validiert --}}{{#if errors}}  <ul class="errors" role="alert">    {{#each errors}}<li>{{this}}</li>{{/each}}  </ul>{{/if}}{{!--  enctype="multipart/form-data" ist PFLICHT für File-Uploads.  name="image" muss zum upload.single("image") in app.js passen.--}}<form method="post" action="/content" enctype="multipart/form-data" class="form" novalidate>  <label>Titel    <input type="text" name="title" value="{{values.title}}" required>  </label>  <label>Beschrieb    <textarea name="description" rows="5" required>{{values.description}}</textarea>  </label>  <label>Kategorie    <select name="category" required>      <option value="" disabled {{#unless values.category}}selected{{/unless}}>Bitte wählen</option>      {{#each categories}}        {{!-- eq-Helper kommt aus deinen Helpers --}}        <option value="{{this}}" {{#if (eq ../values.category this)}}selected{{/if}}>{{this}}</option>      {{/each}}    </select>  </label>  <label>Bild (jpg, png, webp, gif; max. 5 MB)    <input type="file" name="image" accept="image/*" required>  </label>  <button type="submit">Speichern</button></form>3.2 views/content_list.hbs<h1>{{title}}</h1>{{!-- Öffentliche Liste. items kommt aus listContents() --}}{{#if items.length}}  <div class="grid">    {{#each items}}      <article class="card">        {{!-- imagePath ist die relative Web-URL, z. B. /uploads/123abc.png --}}        <img src="{{imagePath}}" alt="{{title}}">        <div class="card-body">          <h2>{{title}}</h2>          <p class="meta">            {{category}} • von {{ownerName}} • {{formatDate createdAt}}          </p>          <p>{{description}}</p>        </div>      </article>    {{/each}}  </div>{{else}}  <p>Noch keine Inhalte.</p>{{/if}}
4) (Optional) Minimales CSS (für schöne Karten)public/css/style.css – nur wenn du magst; hilft bei übersichtlicher Darstellung..grid {  display: grid;  grid-template-columns: repeat(auto-fill, minmax(260px, 1fr));  gap: 1rem;}.card {  border: 1px solid #eee;  border-radius: 10px;  overflow: hidden;  background: #fff;}.card img {  display: block;  width: 100%;  height: auto;}.card-body { padding: .75rem 1rem; }.meta { color: #666; font-size: .9rem; margin: .25rem 0 .75rem; }.errors { background: #ffe8e8; color: #900; padding: .75rem 1rem; border-radius: .5rem; }.form label { display:block; margin-bottom:.75rem; }.form input, .form textarea, .form select { width:100%; padding:.5rem; margin-top:.25rem; }
5) Warum diese Bausteine wichtig sind (Kurz-Erklärung)* Multer: übernimmt das Entgegennehmen von Datei-Uploads und speichert sie sicher im Filesystem.o fileFilter: verhindert, dass Nicht-Bilder hochgeladen werden.o limits.fileSize: schützt deinen Server vor sehr großen Dateien.o Zufälliger Dateiname + geprüfte Extension ? reduziert Kollisionen & Risiken.* DB-Schema:o owner_id verknüpft Inhalte eindeutig mit dem erstellenden User (FK).o CHECK(category IN …): Fehler werden früh abgefangen (auch wenn jemand POST manipuliert).o Indexe machen Listen/Filter/Joins schnell.* Route-Schutz (requireAuth): nur eingeloggte Nutzer sehen das Formular & dürfen Inhalte erstellen.* Sicherheitsdetails:o Uploads landen in public/uploads ? können ausgeliefert werden, enthalten aber keinen ausführbaren Code (nur Bilder).o Bei Validierungsfehlern wird eine bereits gespeicherte Datei wieder gelöscht (kein Müll im Upload-Verzeichnis).6) Quick-Test1. Login (falls nötig vorher registrieren)2. /content/new aufrufen ? Formular sollte sichtbar sein3. Formular ausfüllen + Bild auswählen ? Speichern4. Redirect auf /content ? Karte mit Bild, Titel, Kategorie, Erstellername, Datum sichtbar5. In public/uploads/ sollte die Datei mit zufälligem Namen liegen